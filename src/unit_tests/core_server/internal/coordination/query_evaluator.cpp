#include "core_server/internal/coordination/query_evaluator.hpp"

#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_vector.hpp>

#include "core_server/internal/ceql/query_transformer/annotate_predicates_with_new_physical_predicates.hpp"
#include "core_server/internal/coordination/catalog.hpp"
#include "core_server/internal/evaluation/physical_predicate/compare_math_exprs.hpp"
#include "core_server/internal/evaluation/physical_predicate/compare_with_attribute.hpp"
#include "core_server/internal/evaluation/physical_predicate/compare_with_constant.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryLexer.h"
#include "core_server/internal/parsing/ceql_query/visitors/where_visitor.hpp"
#include "shared/datatypes/client_request.hpp"
#include "shared/datatypes/client_request_type.hpp"
#include "shared/datatypes/event.hpp"
#include "shared/networking/message_sender/zmq_message_sender.hpp"
#include "shared/networking/message_subscriber/zmq_message_subscriber.hpp"
#include "shared/serializer/cereal_serializer.hpp"

using namespace RingTupleQueue;

namespace CORE {
namespace Internal {
namespace CEA {
namespace UnitTests {
namespace COREQueryEvaluatorCoordinationTests {
std::string send(Types::PortNumber inner_thread_port_number,
                 RingTupleQueue::Tuple& event,
                 zmq::context_t& context) {
  ZMQMessageSender sender("inproc://"
                            + std::to_string(inner_thread_port_number),
                          context);
  std::string message = event.serialize_data();
  sender.send(message);
  return message;
}

std::vector<Types::AttributeInfo> attributes_of_event_type_1() {
  std::vector<Types::AttributeInfo> attributes_info;
  attributes_info.emplace_back("String", Types::ValueTypes::STRING_VIEW);
  attributes_info.emplace_back("Integer1", Types::ValueTypes::INT64);
  attributes_info.emplace_back("Integer2", Types::ValueTypes::INT64);
  attributes_info.emplace_back("Double1", Types::ValueTypes::DOUBLE);
  attributes_info.emplace_back("Double2", Types::ValueTypes::DOUBLE);
  return attributes_info;
}

RingTupleQueue::Tuple
add_event_type_1(RingTupleQueue::Queue& ring_tuple_queue,
                 std::string val1,
                 int64_t val2,
                 int64_t val3,
                 double val4,
                 double val5) {
  uint64_t* data = ring_tuple_queue.start_tuple(0);
  char* chars = ring_tuple_queue.writer<std::string>(val1.size());
  memcpy(chars, &val1[0], val1.size());
  int64_t* integer_ptr = ring_tuple_queue.writer<int64_t>();
  *integer_ptr = val2;
  integer_ptr = ring_tuple_queue.writer<int64_t>();
  *integer_ptr = val3;
  double* double_ptr = ring_tuple_queue.writer<double>();
  *double_ptr = val4;
  double_ptr = ring_tuple_queue.writer<double>();
  *double_ptr = val5;
  return ring_tuple_queue.get_tuple(data);
}

std::vector<Types::AttributeInfo> attributes_of_event_type_2() {
  std::vector<Types::AttributeInfo> attributes_info;
  attributes_info.emplace_back("Integer1", Types::ValueTypes::INT64);
  attributes_info.emplace_back("Integer2", Types::ValueTypes::INT64);
  return attributes_info;
}

RingTupleQueue::Tuple
add_event_type_2(RingTupleQueue::Queue& ring_tuple_queue,
                 int64_t val1,
                 int64_t val2) {
  uint64_t* data = ring_tuple_queue.start_tuple(1);
  int64_t* integer_ptr = ring_tuple_queue.writer<int64_t>();
  *integer_ptr = val1;
  integer_ptr = ring_tuple_queue.writer<int64_t>();
  *integer_ptr = val2;
  return ring_tuple_queue.get_tuple(data);
}

std::string create_query(std::string filter_clause) {
  // clang-format off
  return "SELECT ALL * \n"
         "FROM S, S2\n"
         "WHERE S>T \n"
         "--WHERE H+ OR H+\n"
         "FILTER\n"
         + filter_clause + "\n"
         "WITHIN 4 EVENTS\n";
  // clang-format on
}

CEQL::Query parse_query(std::string query) {  // Only parses where correctly
  antlr4::ANTLRInputStream input(query);
  CEQLQueryLexer lexer(&input);
  antlr4::CommonTokenStream tokens(&lexer);
  CEQLQueryParser parser(&tokens);
  antlr4::tree::ParseTree* tree = parser.parse();
  Parsing::WhereVisitor where_visitor;
  where_visitor.visit(tree);
  CEQL::Query parsed_query(CEQL::Select(CEQL::Select::Strategy::ALL,
                                        {},
                                        true),
                           CEQL::From({}),
                           std::move(where_visitor.get_parsed_where()),
                           CEQL::PartitionBy(),
                           CEQL::Within(),
                           CEQL::ConsumeBy());
  return parsed_query;
}

std::vector<std::unique_ptr<PhysicalPredicate>>
get_predicates(CEQL::Query& query, Catalog& catalog) {
  CEQL::AnnotatePredicatesWithNewPhysicalPredicates transformer(catalog);
  query = transformer(std::move(query));
  return std::move(transformer.physical_predicates);
}

TEST_CASE("A sent event is read back by dummy EventStreamer",
          "[server coordination]") {
  // This will fail once the streamer sends complex events.
  Catalog catalog;
  Types::EventTypeId event1_id = catalog.add_event_type(
    "event1", attributes_of_event_type_1());
  Types::EventTypeId event2_id = catalog.add_event_type(
    "event2", attributes_of_event_type_2());
  REQUIRE(event1_id == 0);
  REQUIRE(event2_id == 1);
  RingTupleQueue::Queue queue(100, &catalog.tuple_schemas);
  CEQL::Query query = parse_query(
    create_query("event1[Integer1 >= 20 AND Double1 >= 1.0] AND "
                 "event2[Integer1 <= 30 OR Integer2 > 3]"));
  auto evaluator = Evaluation::PredicateEvaluator(
    get_predicates(query, catalog));
  QueryEvaluator streamer(std::move(evaluator), 5001, 5555, queue);
  streamer.start();
  // There should be no checks at the QueryEvaluator (yet)
  // that an event id is a valid event.
  ZMQMessageSubscriber receiver("tcp://localhost:5555");
  std::string received_message;
  std::thread receiver_thread = std::thread(
    [&]() { received_message = receiver.receive(); });
  std::this_thread::sleep_for(std::chrono::milliseconds(10));
  // TODO:
  RingTupleQueue::Tuple tuple = add_event_type_1(queue,
                                                 "somestring",
                                                 20,
                                                 0,
                                                 0.0,
                                                 1.2);
  send(5001, tuple, streamer.get_inner_thread_context());
  receiver_thread.join();
  REQUIRE("1" == received_message);
  streamer.stop();
}
}  // namespace COREQueryEvaluatorCoordinationTests
}  // namespace UnitTests
}  // namespace CEA
}  // namespace Internal
}  // namespace CORE
