#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_vector.hpp>

#include "core_server/internal/ceql/cel_formula/formula/visitors/get_all_atomic_filters.hpp"
#include "core_server/internal/ceql/query/query.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryLexer.h"
#include "core_server/internal/parsing/ceql_query/visitors/where_visitor.hpp"

using namespace InternalCORECEQLParsing;
using namespace InternalCORECEQL;

namespace COREFormulaVisitorGetAllPredicates {

std::string create_query(std::string filter_clause) {
  // clang-format off
  return "SELECT ALL * \n"
         "FROM S, S2\n"
         "WHERE S>T \n"
         "--WHERE H+ OR H+\n"
         "FILTER\n"
         + filter_clause + "\n"
         "WITHIN 4 EVENTS\n";
  // clang-format on
}

Where parse_where(std::string query) {
  antlr4::ANTLRInputStream input(query);
  CEQLQueryLexer lexer(&input);
  antlr4::CommonTokenStream tokens(&lexer);
  CEQLQueryParser parser(&tokens);
  antlr4::tree::ParseTree* tree = parser.parse();
  WhereVisitor where_visitor;
  where_visitor.visit(tree);
  return where_visitor.get_parsed_where();
}

std::unique_ptr<Formula> parse_formula(std::string query) {
  return std::move(parse_where(query).formula);
}

std::unique_ptr<Predicate> create_example_and_predicate() {
  std::vector<std::unique_ptr<Predicate>> predicates;
  predicates.push_back(std::make_unique<InequalityPredicate>(
      std::make_unique<Attribute>("temp"),
      InequalityPredicate::LogicalOperation::NOT_EQUALS,
      std::make_unique<IntegerLiteral>(50)));
  predicates.push_back(std::make_unique<InequalityPredicate>(
      std::make_unique<Attribute>("temp"),
      InequalityPredicate::LogicalOperation::GREATER,
      std::make_unique<IntegerLiteral>(30)));
  return std::make_unique<AndPredicate>(std::move(predicates));
}

TEST_CASE("get_all_ceql_predicates gets all predicates",
          "[ValueToMathExpr]") {
  GetAllAtomicFilters visitor;
  auto formula = parse_formula(create_query(
      "t2[temp == 50] or (t3[temp != 50 and temp > 30] AND t1[temp < 3])"));
  formula->accept_visitor(visitor);
  std::vector<std::unique_ptr<Predicate>> expected_predicates;
  expected_predicates.push_back(std::make_unique<InequalityPredicate>(
      std::make_unique<Attribute>("temp"),
      InequalityPredicate::LogicalOperation::EQUALS,
      std::make_unique<IntegerLiteral>(50)));
  expected_predicates.push_back(create_example_and_predicate());
  expected_predicates.push_back(std::make_unique<InequalityPredicate>(
      std::make_unique<Attribute>("temp"),
      InequalityPredicate::LogicalOperation::LESS,
      std::make_unique<IntegerLiteral>(3)));
  INFO("Original Formula: " + formula->to_string());
  REQUIRE(visitor.atomic_filters.size() == 3);
  INFO(
      "Note that if this test fails due to order, then the test case "
      "should be fixed (any order should be admissible)");
  for (int i = 0; i < 3; i++) {
    INFO("Expected: " + expected_predicates[i]->to_string()
         + " Got: " + visitor.atomic_filters[i]->predicate->to_string());
    REQUIRE(expected_predicates[i]->equals(
        visitor.atomic_filters[i]->predicate.get()));
  }
}
}  // namespace COREFormulaVisitorGetAllPredicates
