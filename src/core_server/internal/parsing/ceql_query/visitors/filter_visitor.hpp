#include "core_server/internal/ceql/cel_formula/filters/filter_headers.hpp"
#include "core_server/internal/ceql/query/where.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQL_QUERYBaseVisitor.h"
#include "predicate_visitor.hpp"

using namespace InternalCORECEQL;

namespace InternalCORECEQLParsing {
class FilterVisitor : public CEQL_QUERYBaseVisitor {
 private:
  // this filter is the corresponding parsed filter after the
  // visitation to the ctx is finished.
  std::unique_ptr<Filter> filter;

  PredicateVisitor predicate_visitor;

 public:
  std::unique_ptr<Filter> get_parsed_filter() { return std::move(filter); }

  virtual std::any visitAtomic_filter(
      CEQL_QUERYParser::Atomic_filterContext* ctx) override {
    predicate_visitor.visit(ctx->predicate());
    filter = std::make_unique<AtomicFilter>(
        ctx->event_name()->getText(),
        predicate_visitor.get_parsed_predicate());
    return {};
  }

  virtual std::any visitAnd_filter(
      CEQL_QUERYParser::And_filterContext* ctx) override {
    visit(ctx->filter()[0]);
    auto left = std::move(filter);
    visit(ctx->filter()[1]);
    filter =
        std::make_unique<AndFilter>(std::move(left), std::move(filter));
    return {};
  }

  virtual std::any visitOr_filter(
      CEQL_QUERYParser::Or_filterContext* ctx) override {
    visit(ctx->filter()[0]);
    auto left = std::move(filter);
    visit(ctx->filter()[1]);
    filter =
        std::make_unique<OrFilter>(std::move(left), std::move(filter));
    return {};
  }
};
}  // namespace InternalCORECEQLParsing
